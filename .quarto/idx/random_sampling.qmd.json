{"title":"Random Soil Sampling Points Generator","markdown":{"yaml":{"title":"Random Soil Sampling Points Generator","subtitle":"A simple Shiny application for generating random sampling points","author":"Carlos Carbajal","date":"2025-04-17","format":{"html":{"grid":{"body-width":"1200px"},"toc":true,"resources":["shinylive-sw.js"]}},"filters":["shinylive"]},"headingText":"Load required packages","containsRefs":false,"markdown":"\n\n```{shinylive-r}\n#| !! shinylive warning !!: |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 700\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(DT)\nlibrary(leaflet)\nlibrary(ggplot2)\n\n# UI - Simplified for shinylive compatibility\nui <- dashboardPage(\n  skin = \"green\",\n  dashboardHeader(title = \"Random Soil Sampling Tool\"),\n\n  dashboardSidebar(\n    sidebarMenu(\n      menuItem(\"Random Sampling\", tabName = \"sampling\", icon = icon(\"map-marker\")),\n      menuItem(\"About\", tabName = \"about\", icon = icon(\"info-circle\"))\n    )\n  ),\n\n  dashboardBody(\n    tabItems(\n      # Sampling Tab\n      tabItem(tabName = \"sampling\",\n        fluidRow(\n          box(\n            title = \"Sampling Area\", width = 6, status = \"primary\",\n            h4(\"WGS84 (Lat/Long) Coordinates\"),\n            sliderInput(\"lonmin\", \"Longitude Minimum:\", min = -180, max = 180, value = -1, step = 0.01),\n            sliderInput(\"lonmax\", \"Longitude Maximum:\", min = -180, max = 180, value = 1, step = 0.01),\n            sliderInput(\"latmin\", \"Latitude Minimum:\", min = -90, max = 90, value = -1, step = 0.01),\n            sliderInput(\"latmax\", \"Latitude Maximum:\", min = -90, max = 90, value = 1, step = 0.01)\n          ),\n          box(\n            title = \"Sampling Parameters\", width = 6, status = \"primary\",\n            numericInput(\"sampleSize\", \"Number of sample points:\", 30, min = 5, max = 100),\n            checkboxInput(\"addLabels\", \"Add point labels\", TRUE),\n            actionButton(\"runSampling\", \"Generate Random Points\", icon = icon(\"play\"),\n                        class = \"btn-success\"),\n            hr(),\n            HTML(\"<p>Random sampling:</p>\n                 <ul>\n                 <li>Points are selected completely at random</li>\n                 <li>Simple to implement but may miss important areas</li>\n                 <li>Provides unbiased estimates of population parameters</li>\n                 </ul>\")\n          )\n        ),\n        fluidRow(\n          box(\n            title = \"Sampling Results\", width = 12, status = \"success\",\n            tabsetPanel(\n              tabPanel(\"Map\", leafletOutput(\"samplingMap\", height = 500)),\n              tabPanel(\"Data Table\", DTOutput(\"samplingTable\"))\n            )\n          )\n        ),\n        fluidRow(\n          box(\n            title = \"Download Options\", width = 12, status = \"info\",\n            p(\"Note: In this shinylive demo, downloads are simulated.\"),\n            downloadButton(\"downloadData\", \"Download Sample Data (CSV)\", class = \"btn-success\")\n          )\n        )\n      ),\n\n      # About Tab\n      tabItem(tabName = \"about\",\n        fluidRow(\n          box(\n            title = \"About This App\", width = 12, status = \"primary\",\n            p(\"This is a simple application for generating random sampling points for soil surveys or other field sampling designs.\"),\n            p(\"The app is built with Shiny and runs entirely in your browser using shinylive, without requiring a Shiny server.\"),\n            h4(\"How to use:\"),\n            tags$ol(\n              tags$li(\"Set the boundaries for your sampling area using WGS84 coordinates\"),\n              tags$li(\"Choose the number of random points to generate\"),\n              tags$li(\"Click 'Generate Random Points' to create your sampling design\"),\n              tags$li(\"View the results on the map or in the data table\"),\n              tags$li(\"Download the points as a CSV file if needed\")\n            ),\n            h4(\"Coordinate System:\"),\n            tags$p(\"This app uses the WGS84 (World Geodetic System 1984) coordinate system, which is the standard used by GPS devices and most mapping applications.\"),\n            tags$ul(\n              tags$li(strong(\"Latitude:\"), \" Ranges from -90째 (South) to 90째 (North)\"),\n              tags$li(strong(\"Longitude:\"), \" Ranges from -180째 (West) to 180째 (East)\")\n            ),\n\n\n            h4(\"Limitations:\"),\n            p(\"This simplified version only supports random sampling. For more advanced methods like stratified sampling or CLHS, you would need the full version of the app running on a Shiny server.\")\n          )\n        )\n      )\n    )\n  )\n)\n\n# Server logic - Simplified for shinylive compatibility\nserver <- function(input, output, session) {\n  # Reactive values to store data\n  values <- reactiveValues(\n    samplingPoints = NULL,\n    pointsGenerated = FALSE\n  )\n\n  # Generate random sampling points\n  observeEvent(input$runSampling, {\n    # Validate inputs\n    validate <- function() {\n      if (input$lonmin >= input$lonmax) {\n        showNotification(\"Longitude minimum must be less than Longitude maximum\", type = \"error\")\n        return(FALSE)\n      }\n      if (input$latmin >= input$latmax) {\n        showNotification(\"Latitude minimum must be less than Latitude maximum\", type = \"error\")\n        return(FALSE)\n      }\n      return(TRUE)\n    }\n\n    if (!validate()) return(NULL)\n\n    # Generate random points\n    withProgress(message = 'Generating random points...', value = 0, {\n      # Set seed for reproducibility\n      set.seed(as.numeric(Sys.time()))\n\n      # Number of points to generate\n      n <- input$sampleSize\n\n      # Generate points within the bounding box\n      lon <- runif(n, input$lonmin, input$lonmax)\n      lat <- runif(n, input$latmin, input$latmax)\n\n      # Create data frame with points\n      points_df <- data.frame(\n        ID = 1:n,\n        Longitude = round(lon, 2),\n        Latitude = round(lat, 2),\n        CoordSystem = rep(\"wgs84\", n)\n      )\n\n      # Store in reactive values\n      values$samplingPoints <- points_df\n      values$pointsGenerated <- TRUE\n\n      showNotification(paste(n, \"random points generated successfully!\"), type = \"message\")\n    })\n  })\n\n  # Render the map with sampling points\n  output$samplingMap <- renderLeaflet({\n    # Create base map\n    map <- leaflet() %>%\n      addTiles() %>%\n      addScaleBar(position = \"bottomleft\")\n\n    # Add rectangle for WGS84 coordinates\n    map <- map %>%\n      addRectangles(\n        lng1 = input$lonmin, lat1 = input$latmin,\n        lng2 = input$lonmax, lat2 = input$latmax,\n        fillColor = \"transparent\",\n        color = \"blue\",\n        weight = 2,\n        group = \"bounding_box\"\n      )\n\n    # Add points if available\n    if (values$pointsGenerated && !is.null(values$samplingPoints)) {\n      points <- values$samplingPoints\n\n      # Add markers for each point\n      map <- map %>%\n        addCircleMarkers(\n          data = points,\n          lng = ~Longitude, lat = ~Latitude,\n          radius = 5,\n          color = \"red\",\n          fillOpacity = 0.8,\n          stroke = FALSE,\n          group = \"sampling_points\"\n        )\n\n      # Add labels if requested\n      if (input$addLabels) {\n        map <- map %>%\n          addLabelOnlyMarkers(\n            data = points,\n            lng = ~Longitude, lat = ~Latitude,\n            label = ~as.character(ID),\n            labelOptions = labelOptions(\n              noHide = TRUE,\n              direction = 'center',\n              textOnly = TRUE\n            )\n          )\n      }\n\n      # Fit bounds to the sampling area\n      map <- map %>%\n        fitBounds(\n          lng1 = input$lonmin - 0.1, lat1 = input$latmin - 0.1,\n          lng2 = input$lonmax + 0.1, lat2 = input$latmax + 0.1\n        )\n    }\n\n    # Add layer control\n    map <- map %>%\n      addLayersControl(\n        overlayGroups = c(\"sampling_points\", \"bounding_box\"),\n        options = layersControlOptions(collapsed = FALSE)\n      )\n\n    return(map)\n  })\n\n  # Render the data table\n  output$samplingTable <- renderDT({\n    req(values$pointsGenerated, values$samplingPoints)\n\n    # Get points data\n    points <- values$samplingPoints\n\n    # Remove CoordSystem column for display\n    display_points <- points[, !names(points) %in% c(\"CoordSystem\")]\n\n    datatable(\n      display_points,\n      options = list(\n        pageLength = 10,\n        searching = FALSE\n      ),\n      rownames = FALSE\n    )\n  })\n\n  # Render sampling statistics plot\n  output$samplingStats <- renderPlot({\n    req(values$pointsGenerated, values$samplingPoints)\n\n    points <- values$samplingPoints\n\n    # Create a plot showing the distribution of points\n    par(mfrow = c(1, 2))\n\n    # Longitude distribution\n    hist(points$Longitude,\n         main = \"Longitude Distribution\",\n         xlab = \"Longitude\",\n         col = \"lightblue\",\n         border = \"white\")\n\n    # Latitude distribution\n    hist(points$Latitude,\n         main = \"Latitude Distribution\",\n         xlab = \"Latitude\",\n         col = \"lightgreen\",\n         border = \"white\")\n  })\n\n  # Render variable distribution plot\n  output$variableDistribution <- renderPlot({\n    req(values$pointsGenerated, values$samplingPoints)\n\n    # Calculate distance between points\n    points <- values$samplingPoints\n    n <- nrow(points)\n\n    # Create a distance matrix\n    dist_matrix <- matrix(0, nrow = n, ncol = n)\n\n    # Haversine formula for geographic coordinates\n    for (i in 1:n) {\n      for (j in 1:n) {\n        if (i != j) {\n          # Convert to radians\n          lat1 <- points$Latitude[i] * pi / 180\n          lon1 <- points$Longitude[i] * pi / 180\n          lat2 <- points$Latitude[j] * pi / 180\n          lon2 <- points$Longitude[j] * pi / 180\n\n          # Haversine formula\n          dlon <- lon2 - lon1\n          dlat <- lat2 - lat1\n          a <- sin(dlat/2)^2 + cos(lat1) * cos(lat2) * sin(dlon/2)^2\n          c <- 2 * asin(sqrt(a))\n          r <- 6371 # Earth radius in km\n          dist_matrix[i, j] <- r * c\n        }\n      }\n    }\n\n    # Calculate minimum distance for each point\n    min_dist <- apply(dist_matrix, 1, function(x) min(x[x > 0]))\n    points$min_dist <- min_dist\n\n    # Plot minimum distances\n    boxplot(points$min_dist,\n            main = \"Minimum Distance Between Points\",\n            ylab = \"Distance (km)\",\n            col = \"lightblue\")\n  })\n\n  # Download handler for data\n  output$downloadData <- downloadHandler(\n    filename = function() {\n      paste0(\"random_points_\", Sys.Date(), \".csv\")\n    },\n    content = function(file) {\n      req(values$pointsGenerated, values$samplingPoints)\n      write.csv(values$samplingPoints, file, row.names = FALSE)\n    }\n  )\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n```\n","srcMarkdownNoYaml":"\n\n```{shinylive-r}\n#| !! shinylive warning !!: |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 700\n# Load required packages\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(DT)\nlibrary(leaflet)\nlibrary(ggplot2)\n\n# UI - Simplified for shinylive compatibility\nui <- dashboardPage(\n  skin = \"green\",\n  dashboardHeader(title = \"Random Soil Sampling Tool\"),\n\n  dashboardSidebar(\n    sidebarMenu(\n      menuItem(\"Random Sampling\", tabName = \"sampling\", icon = icon(\"map-marker\")),\n      menuItem(\"About\", tabName = \"about\", icon = icon(\"info-circle\"))\n    )\n  ),\n\n  dashboardBody(\n    tabItems(\n      # Sampling Tab\n      tabItem(tabName = \"sampling\",\n        fluidRow(\n          box(\n            title = \"Sampling Area\", width = 6, status = \"primary\",\n            h4(\"WGS84 (Lat/Long) Coordinates\"),\n            sliderInput(\"lonmin\", \"Longitude Minimum:\", min = -180, max = 180, value = -1, step = 0.01),\n            sliderInput(\"lonmax\", \"Longitude Maximum:\", min = -180, max = 180, value = 1, step = 0.01),\n            sliderInput(\"latmin\", \"Latitude Minimum:\", min = -90, max = 90, value = -1, step = 0.01),\n            sliderInput(\"latmax\", \"Latitude Maximum:\", min = -90, max = 90, value = 1, step = 0.01)\n          ),\n          box(\n            title = \"Sampling Parameters\", width = 6, status = \"primary\",\n            numericInput(\"sampleSize\", \"Number of sample points:\", 30, min = 5, max = 100),\n            checkboxInput(\"addLabels\", \"Add point labels\", TRUE),\n            actionButton(\"runSampling\", \"Generate Random Points\", icon = icon(\"play\"),\n                        class = \"btn-success\"),\n            hr(),\n            HTML(\"<p>Random sampling:</p>\n                 <ul>\n                 <li>Points are selected completely at random</li>\n                 <li>Simple to implement but may miss important areas</li>\n                 <li>Provides unbiased estimates of population parameters</li>\n                 </ul>\")\n          )\n        ),\n        fluidRow(\n          box(\n            title = \"Sampling Results\", width = 12, status = \"success\",\n            tabsetPanel(\n              tabPanel(\"Map\", leafletOutput(\"samplingMap\", height = 500)),\n              tabPanel(\"Data Table\", DTOutput(\"samplingTable\"))\n            )\n          )\n        ),\n        fluidRow(\n          box(\n            title = \"Download Options\", width = 12, status = \"info\",\n            p(\"Note: In this shinylive demo, downloads are simulated.\"),\n            downloadButton(\"downloadData\", \"Download Sample Data (CSV)\", class = \"btn-success\")\n          )\n        )\n      ),\n\n      # About Tab\n      tabItem(tabName = \"about\",\n        fluidRow(\n          box(\n            title = \"About This App\", width = 12, status = \"primary\",\n            p(\"This is a simple application for generating random sampling points for soil surveys or other field sampling designs.\"),\n            p(\"The app is built with Shiny and runs entirely in your browser using shinylive, without requiring a Shiny server.\"),\n            h4(\"How to use:\"),\n            tags$ol(\n              tags$li(\"Set the boundaries for your sampling area using WGS84 coordinates\"),\n              tags$li(\"Choose the number of random points to generate\"),\n              tags$li(\"Click 'Generate Random Points' to create your sampling design\"),\n              tags$li(\"View the results on the map or in the data table\"),\n              tags$li(\"Download the points as a CSV file if needed\")\n            ),\n            h4(\"Coordinate System:\"),\n            tags$p(\"This app uses the WGS84 (World Geodetic System 1984) coordinate system, which is the standard used by GPS devices and most mapping applications.\"),\n            tags$ul(\n              tags$li(strong(\"Latitude:\"), \" Ranges from -90째 (South) to 90째 (North)\"),\n              tags$li(strong(\"Longitude:\"), \" Ranges from -180째 (West) to 180째 (East)\")\n            ),\n\n\n            h4(\"Limitations:\"),\n            p(\"This simplified version only supports random sampling. For more advanced methods like stratified sampling or CLHS, you would need the full version of the app running on a Shiny server.\")\n          )\n        )\n      )\n    )\n  )\n)\n\n# Server logic - Simplified for shinylive compatibility\nserver <- function(input, output, session) {\n  # Reactive values to store data\n  values <- reactiveValues(\n    samplingPoints = NULL,\n    pointsGenerated = FALSE\n  )\n\n  # Generate random sampling points\n  observeEvent(input$runSampling, {\n    # Validate inputs\n    validate <- function() {\n      if (input$lonmin >= input$lonmax) {\n        showNotification(\"Longitude minimum must be less than Longitude maximum\", type = \"error\")\n        return(FALSE)\n      }\n      if (input$latmin >= input$latmax) {\n        showNotification(\"Latitude minimum must be less than Latitude maximum\", type = \"error\")\n        return(FALSE)\n      }\n      return(TRUE)\n    }\n\n    if (!validate()) return(NULL)\n\n    # Generate random points\n    withProgress(message = 'Generating random points...', value = 0, {\n      # Set seed for reproducibility\n      set.seed(as.numeric(Sys.time()))\n\n      # Number of points to generate\n      n <- input$sampleSize\n\n      # Generate points within the bounding box\n      lon <- runif(n, input$lonmin, input$lonmax)\n      lat <- runif(n, input$latmin, input$latmax)\n\n      # Create data frame with points\n      points_df <- data.frame(\n        ID = 1:n,\n        Longitude = round(lon, 2),\n        Latitude = round(lat, 2),\n        CoordSystem = rep(\"wgs84\", n)\n      )\n\n      # Store in reactive values\n      values$samplingPoints <- points_df\n      values$pointsGenerated <- TRUE\n\n      showNotification(paste(n, \"random points generated successfully!\"), type = \"message\")\n    })\n  })\n\n  # Render the map with sampling points\n  output$samplingMap <- renderLeaflet({\n    # Create base map\n    map <- leaflet() %>%\n      addTiles() %>%\n      addScaleBar(position = \"bottomleft\")\n\n    # Add rectangle for WGS84 coordinates\n    map <- map %>%\n      addRectangles(\n        lng1 = input$lonmin, lat1 = input$latmin,\n        lng2 = input$lonmax, lat2 = input$latmax,\n        fillColor = \"transparent\",\n        color = \"blue\",\n        weight = 2,\n        group = \"bounding_box\"\n      )\n\n    # Add points if available\n    if (values$pointsGenerated && !is.null(values$samplingPoints)) {\n      points <- values$samplingPoints\n\n      # Add markers for each point\n      map <- map %>%\n        addCircleMarkers(\n          data = points,\n          lng = ~Longitude, lat = ~Latitude,\n          radius = 5,\n          color = \"red\",\n          fillOpacity = 0.8,\n          stroke = FALSE,\n          group = \"sampling_points\"\n        )\n\n      # Add labels if requested\n      if (input$addLabels) {\n        map <- map %>%\n          addLabelOnlyMarkers(\n            data = points,\n            lng = ~Longitude, lat = ~Latitude,\n            label = ~as.character(ID),\n            labelOptions = labelOptions(\n              noHide = TRUE,\n              direction = 'center',\n              textOnly = TRUE\n            )\n          )\n      }\n\n      # Fit bounds to the sampling area\n      map <- map %>%\n        fitBounds(\n          lng1 = input$lonmin - 0.1, lat1 = input$latmin - 0.1,\n          lng2 = input$lonmax + 0.1, lat2 = input$latmax + 0.1\n        )\n    }\n\n    # Add layer control\n    map <- map %>%\n      addLayersControl(\n        overlayGroups = c(\"sampling_points\", \"bounding_box\"),\n        options = layersControlOptions(collapsed = FALSE)\n      )\n\n    return(map)\n  })\n\n  # Render the data table\n  output$samplingTable <- renderDT({\n    req(values$pointsGenerated, values$samplingPoints)\n\n    # Get points data\n    points <- values$samplingPoints\n\n    # Remove CoordSystem column for display\n    display_points <- points[, !names(points) %in% c(\"CoordSystem\")]\n\n    datatable(\n      display_points,\n      options = list(\n        pageLength = 10,\n        searching = FALSE\n      ),\n      rownames = FALSE\n    )\n  })\n\n  # Render sampling statistics plot\n  output$samplingStats <- renderPlot({\n    req(values$pointsGenerated, values$samplingPoints)\n\n    points <- values$samplingPoints\n\n    # Create a plot showing the distribution of points\n    par(mfrow = c(1, 2))\n\n    # Longitude distribution\n    hist(points$Longitude,\n         main = \"Longitude Distribution\",\n         xlab = \"Longitude\",\n         col = \"lightblue\",\n         border = \"white\")\n\n    # Latitude distribution\n    hist(points$Latitude,\n         main = \"Latitude Distribution\",\n         xlab = \"Latitude\",\n         col = \"lightgreen\",\n         border = \"white\")\n  })\n\n  # Render variable distribution plot\n  output$variableDistribution <- renderPlot({\n    req(values$pointsGenerated, values$samplingPoints)\n\n    # Calculate distance between points\n    points <- values$samplingPoints\n    n <- nrow(points)\n\n    # Create a distance matrix\n    dist_matrix <- matrix(0, nrow = n, ncol = n)\n\n    # Haversine formula for geographic coordinates\n    for (i in 1:n) {\n      for (j in 1:n) {\n        if (i != j) {\n          # Convert to radians\n          lat1 <- points$Latitude[i] * pi / 180\n          lon1 <- points$Longitude[i] * pi / 180\n          lat2 <- points$Latitude[j] * pi / 180\n          lon2 <- points$Longitude[j] * pi / 180\n\n          # Haversine formula\n          dlon <- lon2 - lon1\n          dlat <- lat2 - lat1\n          a <- sin(dlat/2)^2 + cos(lat1) * cos(lat2) * sin(dlon/2)^2\n          c <- 2 * asin(sqrt(a))\n          r <- 6371 # Earth radius in km\n          dist_matrix[i, j] <- r * c\n        }\n      }\n    }\n\n    # Calculate minimum distance for each point\n    min_dist <- apply(dist_matrix, 1, function(x) min(x[x > 0]))\n    points$min_dist <- min_dist\n\n    # Plot minimum distances\n    boxplot(points$min_dist,\n            main = \"Minimum Distance Between Points\",\n            ylab = \"Distance (km)\",\n            col = \"lightblue\")\n  })\n\n  # Download handler for data\n  output$downloadData <- downloadHandler(\n    filename = function() {\n      paste0(\"random_points_\", Sys.Date(), \".csv\")\n    },\n    content = function(file) {\n      req(values$pointsGenerated, values$samplingPoints)\n      write.csv(values$samplingPoints, file, row.names = FALSE)\n    }\n  )\n}\n\n# Run the app\nshinyApp(ui = ui, server = server)\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"filters":["shinylive"],"output-file":"random_sampling.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","theme":"cosmo","title":"Random Soil Sampling Points Generator","subtitle":"A simple Shiny application for generating random sampling points","author":"Carlos Carbajal","date":"2025-04-17","grid":{"body-width":"1200px"},"resources":["shinylive-sw.js"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}